<style>
/* Reuse styles or add specific styles */
.mcp-diagram svg {
  max-width: 100%;
  height: auto;
}
</style>

<h1 align="center" id="MCP协议">模型上下文协议 (Model Context Protocol, MCP)</h1>

**概要：** 本章节将介绍模型上下文协议（MCP）的背景、核心概念、工作原理、重要价值。

## 引言：AI 能力的扩展需求

近年来，人工智能（AI），尤其是大型语言模型（LLM），在理解和生成文本方面取得了惊人的进步，然而开源社区和企业对 AI 生态的互操作性提出了更高要求（从`被动回答`转向`主动执行`）。
Hugging Face 等平台推动了模型共享，而 LangChain 等框架尝试通过工具调用（Tool Calling）增强模型能力。然而，这些方案仍未解决根本问题：缺乏一个通用的、标准化的上下文传递机制。行业开始意识到，若没有统一的协议，AI 智能体（Agent）的潜力将难以全面释放。

模型上下文协议（MCP）正是在这一背景下由 Anthropic 于 2024 年 11 月正式推出并开源。作为一家由前 OpenAI 研究人员创立的公司，Anthropic 以其在可解释性和安全 AI 系统方面的专长而闻名。

在此之前LLM存在的固有局限性：

-   **知识截止:** 模型的知识通常停留在其训练数据的时间点，无法获取实时信息。
-   **特定能力缺乏:** 模型本身不擅长或无法执行精确计算、访问外部数据库、操作文件系统或调用特定 API 等任务。
-   **幻觉问题:** 模型有时会“编造”看似合理但实际错误的信息。
-   **无法执行现实世界操作:** 模型本身无法直接与外部世界进行交互（如发送邮件、控制设备）。

为了克服这些限制，让 AI 模型能够更有效地解决现实世界的问题，我们需要一种方法，让它们能够安全、可靠地利用外部世界的 工具 (Tools) 和 信息资源 (Resources) 。这就引出了模型上下文协议 (MCP) 的概念。



## 概述

Model Context Protocol (MCP) 是一个开放协议，用于标准化应用程序如何向大型语言模型(LLM)提供上下文。MCP就像AI应用程序的USB-C接口，提供了一种标准化的方式来连接AI模型与不同的数据源和工具。

MCP的本质：基于[SON-RPC](https://wiki.geekdream.com/Specification/json-rpc_2.0.html)的Function Call加了标准化协议。



扩展：JSON-RPC（JavaScript Object Notation Remote Procedure Call）是一种轻量级、无状态的远程过程调用（RPC）协议，使用 JSON 格式进行数据交换。它允许客户端通过网络请求调用服务器端的函数或方法，并获取响应结果。主要特点：

- **无状态**：每个请求都是独立的，服务器不需要记住客户端的状态。
- **轻量级**：使用 JSON 格式，数据结构简单，易于理解和解析。
- **跨语言支持**：由于 JSON 格式的通用性，JSON-RPC 可以在不同编程语言之间进行通信。
- **支持多种传输协议**：可以通过 HTTP、TCP、WebSocket 等协议进行通信。



## 核心概念

MCP提供三种主要类型的功能：

1. **工具(Tools)**: 可以被LLM调用的函数（需要用户批准）
2. **资源(Resources)**: 可以被客户端读取的类文件数据（如API响应或文件内容）`注意，这个需要用户明确选择提供`
3. **提示(Prompts)**: 预先编写的模板，帮助用户完成特定任务   `注意，这个需要用户明确选择提供`



## MCP的优势

1. **跨平台兼容性**: MCP可以在不同的LLM平台和应用程序之间工作
2. **简化开发**: 开发者可以专注于功能实现，而不是复杂的集成问题
3. **增强用户体验**: 通过提供丰富的上下文和工具，提升AI助手的能力
4. **开放生态系统**: 作为开放协议，鼓励社区贡献和创新



## 与Function Call对比

Function Call

- 简单直接
- 广泛支持
- 标准化结构
- 功能单一
- 缺乏标准协议(内部实现不一)
- 只支持同步调用，缺乏事件机制(要返回了结果才能给LLM，之后才输出...)



MCP

- 相对复杂
- 通用性(不绑定LLM)
- 更完整的功能(工具-资源-提示)
- 标准化协议(JSON-RPC)
- 双向通信(支持事件和通知)
- 细粒度权限(明确控制机制)





## 应用场景

MCP适用于多种场景，包括但不限于：

- **开发环境集成**: 在IDE中使用AI助手进行代码编写和调试
- **数据分析**: 连接数据库和分析工具
- **文档处理**: 读取和处理各种文档格式
- **API集成**: 连接到第三方服务和API
- **文件系统访问**: 安全地访问本地文件系统



## 核心组件

### 协议层

协议层处理消息框架、请求/响应链接和高级通信模式。

主要类包括：

- Protocol：处理消息传递和请求/响应机制
- Client：客户端实现，负责与服务器通信
- Server：服务器实现，提供工具和资源

### 传输层

MCP支持多种传输机制，包括：

1. **WebSockets**：适用于需要双向通信的Web应用程序
2. **HTTP**：适用于简单的请求/响应模式
3. **IPC**：适用于本地进程间通信

### 消息类型

MCP定义了几种核心消息类型：

1. **请求(Request)**：从客户端到服务器的请求，期望得到响应
2. **通知(Notification)**：单向消息，不需要响应
3. **结果(Result)**：对请求的响应，包含请求的结果或错误信息



## 连接生命周期

### 1. 初始化

连接建立时，客户端和服务器交换元数据和能力信息。这包括：

- 版本兼容性检查
- 可用工具和资源的发现
- 认证和授权（如果需要）

### 2. 消息交换

连接建立后，客户端和服务器可以交换消息：

- 客户端可以请求资源或调用工具
- 服务器可以响应请求并发送通知
- 双方都可以发送心跳消息以保持连接活跃

### 3. 终止

连接可以由任一方终止：

- 正常关闭：通过关闭消息优雅地终止
- 异常关闭：由于错误或超时导致的终止



## 主要接口路径

- tools/list-获取可用工具
- tools/call-调用工具
- resources/list-获取可用资源
- resources/red-读取资源内容
- prompts/list-获取可用提示
- prompts/get-获取提示内容

```js
// 列出工具列表的请求体
{
  "jsonrpc": "2.0",
  "id": 2,
  "name": "tools/list"
}

// 调用工具的请求
{
    "jsonrpc": "2.0",
    "id": 3,
    "method": "tools/call",
    "params": {
        "name": "check_weather",
        "arguments": {
            "city": "Beijing"
        }
    }
}
```



MCP中的工具允许服务器暴露可执行函数，这些函数可以被客户端调用并被LLM用来执行操作。工具的关键方面包括：

- **发现**：客户端可以通过`tools/list`端点列出可用工具
- **调用**：工具通过`tools/call`端点被调用，服务器执行请求的操作并返回结果
- **灵活性**：工具可以从简单的计算到复杂的API交互

与资源类似，工具由唯一名称标识，并可以包含描述以指导其使用。然而，与资源不同，工具代表可以修改状态或与外部系统交互的动态操作。



每个工具都使用以下结构定义：

```js
{
  "name": "string",          // 工具的唯一标识符
  "description": "string",   // 人类可读的描述（可选）
  "inputSchema": {           // 工具参数的JSON Schema
    "type": "object",
    "properties": { ... }    // 工具特定的参数
  }
}
```



## 实现工具

实现MCP工具涉及以下步骤：

1. **定义工具接口**：指定工具的名称、描述和输入参数
2. **实现工具逻辑**：编写执行工具功能的代码
3. **处理错误和边缘情况**：确保工具能够优雅地处理错误
4. **注册工具**：将工具注册到MCP服务器



## 示例

### 系统操作

系统操作工具允许LLM与操作系统交互，例如：

```js
{
  "name": "file_system/read_file",
  "description": "读取文件内容",
  "inputSchema": {
    "type": "object",
    "properties": {
      "path": {
        "type": "string",
        "description": "要读取的文件路径"
      }
    },
    "required": ["path"]
  }
}
```

### API集成

API集成工具允许LLM与外部服务交互：

```js
{
  "name": "weather/get_forecast",
  "description": "获取指定位置的天气预报",
  "inputSchema": {
    "type": "object",
    "properties": {
      "location": {
        "type": "string",
        "description": "位置名称或坐标"
      },
      "days": {
        "type": "integer",
        "description": "预报天数",
        "default": 1
      }
    },
    "required": ["location"]
  }
}
```

### 数据处理

数据处理工具允许LLM执行数据转换和分析：

```js
{
  "name": "data/parse_csv",
  "description": "解析CSV数据",
  "inputSchema": {
    "type": "object",
    "properties": {
      "data": {
        "type": "string",
        "description": "CSV格式的数据"
      },
      "header": {
        "type": "boolean",
        "description": "数据是否包含标题行",
        "default": true
      }
    },
    "required": ["data"]
  }
}
```

### 工具设计

- **命名一致性**：使用一致的命名约定（如`domain/action`）
- **详细描述**：提供清晰的描述，说明工具的功能和用法
- **合理默认值**：为可选参数提供合理的默认值
- **参数验证**：使用JSON Schema验证输入参数

### 输入验证

- 验证所有工具输入以防止注入攻击
- 实施参数类型检查和范围验证
- 对敏感输入进行清理和转义

### 访问控制

- 实现基于角色的访问控制
- 限制对敏感工具的访问
- 考虑用户确认敏感操作



## 总结

MCP就是一个标准化协议，一个基于[SON-RPC](https://wiki.geekdream.com/Specification/json-rpc_2.0.html)的Function Call加了标准化协议。
