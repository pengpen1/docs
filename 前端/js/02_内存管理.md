<h1 align="center" id="内存管理">内存管理</h1>

## 栈内存和堆内存

在 JavaScript 中，内存主要分为两种：栈内存和堆内存。

栈内存（Stack Memory）是基于后进先出原则的内存区域，主要用于存储基本数据类型（如数字、布尔值、字符串等）以及对象的引用地址。

堆内存（Heap Memory）是一个较大的内存区域，用于存储对象和动态分配的数据。在 JavaScript 中，所有对象（包括对象、数组、函数等）都存储在堆内存中。

栈内存和堆内存的分配和释放是由 JavaScript 引擎自动管理的。

| **特性**     | **栈内存（Stack Memory）**                      | **堆内存（Heap Memory）**                  |
| :----------- | :---------------------------------------------- | :----------------------------------------- |
| **存储内容** | 基本数据类型（如数字、布尔值、null、undefined） | 对象和复杂数据结构（如对象、数组、字符串） |
| **分配方式** | 静态分配，大小固定                              | 动态分配，大小可变                         |
| **访问速度** | 快                                              | 较慢                                       |
| **生命周期** | 函数执行完毕后自动释放                          | 需要垃圾回收机制来清理不再使用的对象       |
| **引用关系** | 栈中存储的是堆中对象的引用地址                  | 堆中存储的是实际的对象数据                 |

理解栈内存与堆内存，那再理解引用传递，垃圾回收这些就简单多了。

```js
function add(a, b) {
  let sum = a + b; // `sum` 是一个基本数据类型，存储在栈内存中
  return sum;
}

let result = add(5, 3); // `result` 是一个基本数据类型，存储在栈内存中
let obj = { name: 'Alice' }; // 对象存储在堆内存中，栈中存储的是引用地址


// 小试牛刀
let m = { a: 10, b: 20 }
let n = m;
n.a = 15;

// 这时m.a的值是多少?
```



## 垃圾回收机制

底层语言（如 C 语言）拥有手动的内存管理原语。相反，JavaScript 是在创建对象时自动分配内存，并在不再使用时自动释放内存（*垃圾回收*）。垃圾回收算法依赖的主要概念是引用。在内存管理的上下文中，如果一个对象有访问另一个对象的权限（隐式或者显式），称作前面的对象引用后面的对象。例如，一个 JavaScript 对象具有对它的[原型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain)的引用（隐式引用）和对它属性的引用（显式引用）。



1）[引用计数垃圾回收](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Memory_management#引用计数垃圾回收)

这是最初级的垃圾回收算法。此算法把确定对象是否仍然需要这个问题简化为确定对象是**否仍有其他引用它的对象**。如果没有指向该对象的引用，那么该对象称作“垃圾”或者可回收的。

这个算法有个弊端，那就是无妨处理**循环引用**，因为相互都有引用，就都不会被标记成可回收对象，从而导致**内存泄漏**。



2）[标记清除算法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Memory_management#标记清除算法)

这个算法将**对象不再需要**这个定义简化为**对象不可达**。

这个算法假定有一组叫做*根*的对象。在 JavaScript 中，根是全局对象。垃圾回收器将定期从这些根开始，找到从这些根能引用到的所有对象，然后找到从这些对象能引用到的所有对象，等等。从根开始，垃圾回收器将找到所有*可到达*的对象并收集所有不能到达的对象。

这个算法就是上一个算法的改进，解决了循环引用的弊端。

当前，所有现代的引擎搭载的是标记清除垃圾回收器。



## 闭包

在JavaScript中，函数是非常重要的，并且是一等公民，函数可以作为另外一个函数的参数，也可以作为另外一个函数的返回值来使用，总之是非常灵活的。

**在计算机科学中对闭包的定义（维基百科）：**

- 闭包（英语：Closure），又称**词法闭包**（Lexical Closure）或**函数闭包**（function closures）；
- 是在支持 **头等函数** 的编程语言中，实现词法绑定的一种技术；
- 闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）；
- 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 **自由变量** 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行



**MDN中是这样解释的：**

- 一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）；
- 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；
- 在 JavaScript 中，**每当创建一个函数，闭包就会在函数创建的同时被创建出来**；



```js
const a = 15;

const demo = () => {
  console.log("demo=>", a);
};
const demo2 = () => {
  const a = 20;
  console.log("demo2=>", a);
  demo();
};

demo2(); // demo2=> 20 demo=> 15
```

重点是组合，函数和其关联环境的组合才是闭包。



## 闭包（深入进阶）

要深入理解闭包的原理，我们需要知道几个概念：上下文执行栈（Execution Context Stack, ECS）、作用域链（Scope Chain）、变量对象（Variable Object, VO）、全局对象（Global Object，GO）、活动变量（Active Variables）。

下文执行栈是一个后进先出（LIFO）的数据结构，用于管理 JavaScript 代码的执行上下文。每个执行上下文代表一个正在执行的代码块（如全局代码、函数代码或 eval 代码）。当 JavaScript 引擎执行代码时，它会将当前的**执行上下文**压入栈顶，并在执行完毕后将其弹出。



执行上下文由三部分组成：

1. **变量对象（Variable Object, VO）**：

   存储当前上下文中的变量、函数声明和参数。

   全局上下文的变量对象是全局对象（GO）。

   函数上下文的变量对象是活动对象（Activation Object）。

2. **作用域链（Scope Chain）**：

   用于变量的查找和解析。

   由当前上下文的变量对象和其父上下文的变量对象组成。

3. **this 指针**：

   指向当前上下文的 `this` 值。



执行上下文的生命周期：

1. **进入上下文**：

   创建变量对象。

   建立作用域链。

   确定 `this` 的值。

2. **执行上下文**：

   执行代码，解析变量和函数。

3. **退出上下文**：

   变量对象被销毁。

   执行上下文从栈中弹出。



作用域链的工作原理：

作用域链是执行上下文的一部分，用于变量的查找和解析。它由当前上下文的变量对象和其父上下文的变量对象组成。作用域链的长度取决于嵌套的上下文深度。

当 JavaScript 引擎解析变量时，它会从当前上下文的变量对象开始查找。

如果找不到，它会沿着作用域链向上查找，直到找到变量或到达全局上下文。



活动变量：

活动变量是当前执行上下文中活动对象（Activation Object）的属性，这些属性对应于函数的参数和局部变量。活动对象是函数上下文的变量对象。

即`VO:AO`



## 综合例子（深入进阶）

```js
const makeAdder = (count) => {
  return (demo = (num) => {
    return count + num;
  });
};

const add10= makeAdder(10);
console.log(add10(5)); // 15
```

![](https://cdn.jsdelivr.net/gh/pengpen1/blog-images/执行上下文.png)

<p align="center">图片来自coderwhy老师的PPT</p>

![](https://cdn.jsdelivr.net/gh/pengpen1/blog-images/示意图.png)

<p align="center">图片来自coderwhy老师的PPT</p>

全局代码进入执行上下文，创建变量对象，此时VO指向GO。

执行代码到`const add10= makeAdder(10)`，V8 引擎将 `makeAdder` 函数的执行上下文压入执行上下文栈，创建一个新的变量对象（VO），包含函数参数 `count` 和返回的匿名函数，以及建立作用域链，包括当前函数的变量对象和全局变量对象。执行函数体返回一个匿名函数，该函数捕获了 `count` 的值，形成了一个闭包（Closure），并赋值给全局变量add10，函数执行完毕后，其执行上下文从栈中弹出。正常情况，AO对象应该被销毁，但是作用域引用指向了这个AO对象，所以[标记清除算法](#垃圾回收机制)能从根对象找到这个AO对象，所以不会被回收掉。这就是为什么闭包容易造成内存泄漏的原因。解决方案也很简单，将add10赋值为null即可。



## 关联考点

1. 闭包与内存管理
2. 内存泄漏的原因与防范
3. this指向